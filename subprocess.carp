(system-include "unistd.h")

(relative-include "./subprocess.h")

(register-type SubProcessPipe "CarpSubprocess_Pipe")

(defmodule SubProcessPipe
  (register init (Fn [] SubProcessPipe) "CarpSubprocess_PipeInit")
  (register input (Fn [(Ref SubProcessPipe)] Int) "CarpSubprocess_PipeInput")
  (register output (Fn [(Ref SubProcessPipe)] Int) "CarpSubprocess_PipeOutput")

  (register copy (Fn [(Ref SubProcessPipe)] SubProcessPipe) "CarpSubprocess_PipeCopy")
  (implements copy copy)

  (defn str [p] (do (ignore (the (Ref SubProcessPipe) p)) @"SubProcessPipe"))
  (implements str str)
  (defn prn [p] (do (ignore (the (Ref SubProcessPipe) p)) @"SubProcessPipe"))
  (implements prn prn))

(deftype SubProcessOutMode Std Pipe)
(deftype SubProcessErrMode Std Pipe Combine)

(deftype SubProcessOptions [out SubProcessOutMode err SubProcessErrMode])
(defmodule SubProcessOptions
  (defn std [] (SubProcessOptions (SubProcessOutMode.Std) (SubProcessErrMode.Std)))
  (defn pipe-combine [] (SubProcessOptions (SubProcessOutMode.Pipe) (SubProcessErrMode.Combine)))
  (defn pipe [] (SubProcessOptions (SubProcessOutMode.Pipe) (SubProcessErrMode.Pipe)))

  (defn zero [] (std))
  (implements zero zero))

(deftype SubProcess [out (Maybe String) err (Maybe String) exit-code Int])

(defmodule SubProcess
  (register fork (Fn [] Int) "fork")
  (register close (Fn [Int] ()) "close")
  (register execvp (Fn [(Ptr CChar) (Ptr (Ptr CChar))] Int) "execvp")
  (register wait (Fn [(Ptr Int)] ()) "wait")
  (register read (Fn [Int (Ptr Byte) Int] Int) "read")
  (register dup2 (Fn [Int Int] Int) "dup2")
  (register pipe (Fn [(Ptr Int)] ()) "pipe")
  (deftemplate exit-status (Fn [Int] Int) "int $NAME(int status)" "$DECL { return WEXITSTATUS(status); }")

  (defn-do child-process [args fd errfd options]
    (match-ref (SubProcessOptions.out options)
      Pipe
      (do (close (SubProcessPipe.output fd))
          (ignore (dup2 (SubProcessPipe.input fd) 1)))
      _ ())

    (match-ref (SubProcessOptions.err options)
      Pipe
      (do (close (SubProcessPipe.output errfd))
          (ignore (dup2 (SubProcessPipe.input errfd) 2)))
      Combine
      (match-ref (SubProcessOptions.out options)
        Pipe (ignore (dup2 (SubProcessPipe.input fd) 2))
        Std  (ignore (dup2 1 2)))
      _ ())

    (ignore (execvp (Array.unsafe-nth-value args 0) (Array.unsafe-raw args))) ; TODO: Deal with the fact that there might not be a first value in array
    (exit 1))

  (defn-do parent-process [out-pipe err-pipe options]
    (let-do [out-continue true
             err-continue true
             buff-size 1 ; One byte at a time TODO: buffer this
             out-buff (the (Array Byte) [])
             err-buff (the (Array Byte) [])
             out-current-char (the Byte (zero))
             err-current-char (the Byte (zero))
             out-byte-read 0
             err-byte-read 0
             status -1]

      (match-ref (SubProcessOptions.out options)
        Pipe (close (SubProcessPipe.input out-pipe))
        _ ())

      (match-ref (SubProcessOptions.err options)
        Pipe (close (SubProcessPipe.input err-pipe))
        _ ())

      (while-do (or out-continue err-continue)

        (when out-continue
          (match-ref (SubProcessOptions.out options)
            Pipe
            (do
              (set! out-byte-read (read (SubProcessPipe.output out-pipe)
                                        (Pointer.address &out-current-char)
                                        buff-size))
              (if (> out-byte-read 0)
                (Array.push-back! &out-buff out-current-char)
                (set! out-continue false)))
            _ (set! out-continue false)))

        (when err-continue
          (match-ref (SubProcessOptions.err options)
            Pipe
            (do
              (set! err-byte-read (read (SubProcessPipe.output err-pipe)
                                        (Pointer.address &err-current-char)
                                        buff-size))
              (if (> err-byte-read 0)
                (Array.push-back! &err-buff err-current-char)
                (set! err-continue false)))
            _ (set! err-continue false))))

      (wait (Pointer.address &status))
      (init
       (match-ref (SubProcessOptions.out options)
         Pipe (Just (String.from-bytes &out-buff))
         _ (Nothing))
       (match-ref (SubProcessOptions.err options)
         Pipe (Just (String.from-bytes &err-buff))
         _ (Nothing))
       (exit-status status))))

  (defn fork-and-process [args options]
    (let-do [out-pipe &(SubProcessPipe.init)
             err-pipe &(SubProcessPipe.init)
             pid -1]

       (set! pid (fork))
       (cond (< pid 0) (do (println* "Fail") (exit 1))
             (= pid 0) (child-process args out-pipe err-pipe options)
             (parent-process out-pipe err-pipe options))))

  (defn cmd [options args]
    (let-do [len (Array.length args)
             c-args (Array.allocate (inc len))]
      (for [i 0 len]
        (Array.aset-uninitialized! &c-args i (cstr (Array.unsafe-nth args i))))
      (Array.aset-uninitialized! &c-args (dec (Array.length &c-args)) NULL)
      (fork-and-process &c-args &options))))

