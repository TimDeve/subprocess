(system-include "unistd.h")

(relative-include "./subprocess.h")

(register-type SubprocessPipe "CarpSubprocess_Pipe")
(defmodule SubprocessPipe
  (register init (Fn [] SubprocessPipe) "CarpSubprocess_PipeInit")
  (register input (Fn [(Ref SubprocessPipe)] Int) "CarpSubprocess_PipeInput")
  (register output (Fn [(Ref SubprocessPipe)] Int) "CarpSubprocess_PipeOutput")

  (register copy (Fn [(Ref SubprocessPipe)] SubprocessPipe) "CarpSubprocess_PipeCopy")
  (implements copy copy)

  (defn str [p] (do (ignore (the (Ref SubprocessPipe) p)) @"SubprocessPipe"))
  (implements str str)
  (defn ref-prn [p] (do (ignore (the (Ref SubprocessPipe) p)) @"SubprocessPipe"))
  (implements prn ref-prn)
  (defn prn [p] (do (ignore (the SubprocessPipe p)) @"SubprocessPipe"))
  (implements prn prn))

(deftype SubprocessOutMode Std Pipe)
(deftype SubprocessErrMode Std Pipe Out)
(deftype SubprocessOptions [out SubprocessOutMode err SubprocessErrMode])
(defmodule SubprocessOptions
  (defn std [] (SubprocessOptions (SubprocessOutMode.Std) (SubprocessErrMode.Std)))
  (defn pipe-combine [] (SubprocessOptions (SubprocessOutMode.Pipe) (SubprocessErrMode.Out)))
  (defn pipe [] (SubprocessOptions (SubprocessOutMode.Pipe) (SubprocessErrMode.Pipe)))

  (defn zero [] (std))
  (implements zero zero))

(deftype SubprocessRes [out (Maybe String) err (Maybe String) exit-code Int])

(deftype Subprocess [out (Maybe SubprocessPipe) err (Maybe SubprocessPipe)])
(defmodule Subprocess
  (private fork) (hidden fork)
  (register fork (Fn [] Int) "fork")
  (private close) (hidden close)
  (register close (Fn [Int] ()) "close")
  (private execvp) (hidden execvp)
  (register execvp (Fn [(Ptr CChar) (Ptr (Ptr CChar))] Int) "execvp")
  (private wait) (hidden wait)
  (register wait (Fn [(Ptr Int)] ()) "wait")
  (private read) (hidden read)
  (register read (Fn [Int (Ptr Byte) Int] Int) "read")
  (private dup2) (hidden dup2)
  (register dup2 (Fn [Int Int] Int) "dup2")
  (private pipe) (hidden pipe)
  (register pipe (Fn [(Ptr Int)] ()) "pipe")
  (private exit-status) (hidden exit-status)
  (deftemplate exit-status (Fn [Int] Int) "int $NAME(int status)" "$DECL { return WEXITSTATUS(status); }")

  (defn- child-process [args fd errfd options]
    (do
     (match-ref (SubprocessOptions.out options)
       Pipe
       (do (close (SubprocessPipe.output fd))
           (ignore (dup2 (SubprocessPipe.input fd) 1)))
       _ ())

     (match-ref (SubprocessOptions.err options)
       Pipe
       (do (close (SubprocessPipe.output errfd))
           (ignore (dup2 (SubprocessPipe.input errfd) 2)))
       Out
       (match-ref (SubprocessOptions.out options)
         Pipe (ignore (dup2 (SubprocessPipe.input fd) 2))
         Std  (ignore (dup2 1 2)))
       _ ())

     (ignore (execvp (Array.unsafe-nth-value args 0) (Array.unsafe-raw args))) ; TODO: Deal with the fact that there might not be a first value in array
     (exit 1))) ; Should not be reached

  (defn- parent-process [out-pipe err-pipe options]
    (let [maybe-out-pipe
          (match-ref (SubprocessOptions.out options)
            Pipe (Just out-pipe)
            _    (Nothing))
          maybe-err-pipe
          (match-ref (SubprocessOptions.err options)
            Pipe (Just err-pipe)
            Out  (Nothing)
            _    (Nothing))]
      (init maybe-out-pipe maybe-err-pipe)))

  (defn- fork-and-process [args options]
    (let-do [out-pipe (SubprocessPipe.init)
             *out-pipe &out-pipe
             err-pipe (SubprocessPipe.init)
             *err-pipe &err-pipe
             pid -1]

       (set! pid (fork))
       (cond (< pid 0) (do (println* "Fail") (exit 1))
             (= pid 0) (child-process args *out-pipe *err-pipe options)
             (parent-process out-pipe err-pipe options))))

  (sig call (Fn [SubprocessOptions (Ref (Array String))] Subprocess))
  (defn call [options args]
    (let-do [len (Array.length args)
             c-args (Array.allocate (inc len))]
      (for [i 0 len]
        (Array.aset-uninitialized! &c-args i (cstr (Array.unsafe-nth args i))))
      (Array.aset-uninitialized! &c-args (dec (Array.length &c-args)) NULL)
      (fork-and-process &c-args &options)))

  (sig collect (Fn [Subprocess] SubprocessRes))
  (defn-do collect [subp]
    (let-do [out-continue true
             err-continue true
             buff-size 1 ; One byte at a time TODO: buffer this
             out-buff (the (Array Byte) [])
             err-buff (the (Array Byte) [])
             out-current-char (the Byte (zero))
             err-current-char (the Byte (zero))
             out-byte-read 0
             err-byte-read 0
             status -1]

      (match-ref (Subprocess.out &subp)
        (Just pipe) (close (SubprocessPipe.input pipe))
        _ ())

      (match-ref (Subprocess.err &subp)
        (Just pipe) (close (SubprocessPipe.input pipe))
        _ ())

      (while-do (or out-continue err-continue)

        (when out-continue
          (match-ref (Subprocess.out &subp)
            (Just pipe)
            (do
              (set! out-byte-read (read (SubprocessPipe.output pipe)
                                        (Pointer.address &out-current-char)
                                        buff-size))
              (if (> out-byte-read 0)
                (Array.push-back! &out-buff out-current-char)
                (set! out-continue false)))
            _ (set! out-continue false)))

        (when err-continue
          (match-ref (Subprocess.err &subp)
            (Just pipe)
            (do
              (set! err-byte-read (read (SubprocessPipe.output pipe)
                                        (Pointer.address &err-current-char)
                                        buff-size))
              (if (> err-byte-read 0)
                (Array.push-back! &err-buff err-current-char)
                (set! err-continue false)))
            _ (set! err-continue false))))

      (wait (Pointer.address &status))
      (SubprocessRes.init
       (match-ref (Subprocess.out &subp)
         (Just _)  (Just (String.from-bytes &out-buff))
         _ (Nothing))
       (match-ref (Subprocess.err &subp)
         (Just _) (Just (String.from-bytes &err-buff))
         _ (Nothing))
       (exit-status status))))

  (sig cmd (Fn [SubprocessOptions (Ref (Array String))] SubprocessRes))
  (defn cmd [opts args] (collect (call opts args))))

